<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D随机地牢地图生成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 400px;
        }
        .control-item {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            min-width: 120px;
            text-align: right;
        }
        input[type="range"] {
            width: 200px;
        }
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        button {
            padding: 8px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            width: 100%;
        }
        button:hover {
            background-color: #45a049;
        }
        #generateSpawnBtn {
            background-color: #2196F3;
        }
        #generateSpawnBtn:hover {
            background-color: #0b7dda;
        }
        #generateEventBtn {
            background-color: #FFC107;
            color: #333;
        }
        #generateEventBtn:hover {
            background-color: #FFB300;
        }
        #exportTMXBtn {
            background-color: #9C27B0;
        }
        #exportTMXBtn:hover {
            background-color: #7B1FA2;
        }
        #exportTSXBtn {
            background-color: #FF5722;
        }
        #exportTSXBtn:hover {
            background-color: #E64A19;
        }
        .image-upload {
            margin: 15px 0;
            padding: 10px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
        }
        .image-upload:hover {
            border-color: #666;
        }
        #tileImagePreview {
            max-width: 100%;
            max-height: 100px;
            margin-top: 10px;
            display: none;
        }
        canvas {
            border: 2px solid #333;
            background-color: #ddd;
        }
        .value-display {
            min-width: 30px;
            text-align: center;
            font-weight: bold;
        }
        .spawn-label {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        .event-label {
            position: absolute;
            color: black;
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px 2px white;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="controls">
        <!-- 画布宽高输入框，建议放在最顶部 -->
        <div class="control-item">
            <label for="canvasWidth">画布宽度：</label>
            <input type="number" id="canvasWidth" min="10" max="100" value="50" style="width:60px;">
            <label for="canvasHeight">高度：</label>
            <input type="number" id="canvasHeight" min="10" max="100" value="50" style="width:60px;">
        </div>
        <div class="control-item">
            <label for="rectCount">矩形数量：</label>
            <input type="range" id="rectCount" min="1" max="10" value="2">
            <span class="value-display" id="rectCountValue">2</span>
        </div>
        <div class="control-item">
            <label for="minRectSize">矩形最小尺寸：</label>
            <input type="number" id="minRectSize" min="5" max="50" value="14" style="width:60px;">
            <label for="maxRectSize">最大尺寸：</label>
            <input type="number" id="maxRectSize" min="5" max="50" value="25" style="width:60px;">
        </div>
        <div class="control-item">
            <label for="doorCount">通道数量：</label>
            <input type="range" id="doorCount" min="1" max="4" value="2">
            <span class="value-display" id="doorCountValue">2</span>
            <label style="margin-left:20px;"><input type="checkbox" id="doorCenter">是否正中</label>
        </div>
        <div class="control-item">
            <label>通道方向：</label>
            <label><input type="checkbox" id="doorTop">正上</label>
            <label><input type="checkbox" id="doorRight">正右</label>
            <label><input type="checkbox" id="doorBottom">正下</label>
            <label><input type="checkbox" id="doorLeft">正左</label>
            <span style="min-width: auto;">勾选即生成，数量与勾选数一致</span>
        </div>
        <div class="control-item">
            <label for="pathWidth">路径宽度（格）：</label>
            <input type="range" id="pathWidth" min="1" max="10" value="3">
            <span class="value-display" id="pathWidthValue">3</span>
            <label style="margin-left:20px;"><input type="checkbox" id="pathStraight">是否路径为直线</label>
        </div>
        <div class="control-item">
            <label for="monsterCount">怪物生成点：</label>
            <input type="range" id="monsterCount" min="1" max="7" value="3">
            <span class="value-display" id="monsterCountValue">3</span>
        </div>
        <div class="control-item">
            <label for="eventCount">特殊事件点：</label>
            <input type="range" id="eventCount" min="1" max="10" value="2">
            <span class="value-display" id="eventCountValue">2</span>
        </div>
        <div class="control-item">
            <label for="outputName">输出名称：</label>
            <input type="text" id="outputName" value="dungeon_map" style="width:180px;">
        </div>
        <div class="image-upload" id="imageUploadArea">
            点击上传你的图块集图片（建议尺寸：每个图块64x64，横向排列）
            <input type="file" id="tileImageInput" accept="image/png,image/jpg,image/jpeg" style="display: none;">
            <img id="tileImagePreview" alt="图块预览">
        </div>
        <button id="regenerateBtn">重新生成地图</button>
        <button id="generateSpawnBtn">生成怪物/玩家出生点</button>
        <button id="generateEventBtn">生成特殊事件刷新点</button>
        <button id="exportTMXBtn">导出TMX文件</button>
        <button id="exportTSXBtn">下载TSX图块文件</button>
        <button id="editSpawnsBtn" style="background-color:#FF7043;">编辑生成点</button>
        <button id="saveSpawnsBtn" style="background-color:#607D8B; display:none;">保存位置</button>
    </div>
    <canvas id="mapCanvas" width="800" height="800"></canvas>
    <div id="labelsContainer" style="position: relative; width: 800px; height: 800px; margin-top: -800px; pointer-events: none;"></div>

    <script>
        // 全局配置
        const config = {
            mapWidth: 50,
            mapHeight: 50,
            cellSize: 16,
            wallThickness: 1,
            doorSize: 3,
            edgeAvoid: 3,
            colors: {
                normalWall: '#666666',
                pathWall: '#000000',
                path: '#4CAF50',
                door: '#FF69B4',
                background: '#dddddd',
                monsterSpawn: '#FF0000',
                playerSpawn: '#0000FF',
                eventSpawn: '#FFFF00'
            },
            tmxTileSize: 64,
            tileSetColumns: 10,
            tileSetImageName: 'dungeon_tileset.png'
        };

        let uploadedTileImage = null;
        let tileImageBase64 = null;

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const rectCountSlider = document.getElementById('rectCount');
        const rectCountValue = document.getElementById('rectCountValue');
        const doorCountSlider = document.getElementById('doorCount');
        const doorCountValue = document.getElementById('doorCountValue');
        const minRectSizeInput = document.getElementById('minRectSize');
        const maxRectSizeInput = document.getElementById('maxRectSize');
        const outputNameInput = document.getElementById('outputName');
        const pathWidthSlider = document.getElementById('pathWidth');
        const pathWidthValue = document.getElementById('pathWidthValue');
        const monsterCountSlider = document.getElementById('monsterCount');
        const monsterCountValue = document.getElementById('monsterCountValue');
        const eventCountSlider = document.getElementById('eventCount');
        const eventCountValue = document.getElementById('eventCountValue');
        const doorTopCheckbox = document.getElementById('doorTop');
        const doorRightCheckbox = document.getElementById('doorRight');
        const doorBottomCheckbox = document.getElementById('doorBottom');
        const doorLeftCheckbox = document.getElementById('doorLeft');
        const imageUploadArea = document.getElementById('imageUploadArea');
        const tileImageInput = document.getElementById('tileImageInput');
        const tileImagePreview = document.getElementById('tileImagePreview');
        const regenerateBtn = document.getElementById('regenerateBtn');
        const generateSpawnBtn = document.getElementById('generateSpawnBtn');
        const generateEventBtn = document.getElementById('generateEventBtn');
        const exportTMXBtn = document.getElementById('exportTMXBtn');
        const exportTSXBtn = document.getElementById('exportTSXBtn');
        const labelsContainer = document.getElementById('labelsContainer');
        const editSpawnsBtn = document.getElementById('editSpawnsBtn');
        const saveSpawnsBtn = document.getElementById('saveSpawnsBtn');
        const canvasWidthInput = document.getElementById('canvasWidth');
        const canvasHeightInput = document.getElementById('canvasHeight');
        const doorCenterCheckbox = document.getElementById('doorCenter');
        const pathStraightCheckbox = document.getElementById('pathStraight');

        let editMode = false;
        let dragging = null;
        const spawnPickRadiusPx = config.cellSize * 0.8;

        let monsterSpawnPoints = [];
        let playerSpawnPoint = null;
        let eventSpawnPoints = [];
        let doorPositions = [];
        let doorCenters = [];

        rectCountValue.textContent = rectCountSlider.value;
        doorCountValue.textContent = doorCountSlider.value;
        pathWidthValue.textContent = pathWidthSlider.value;
        monsterCountValue.textContent = monsterCountSlider.value;
        eventCountValue.textContent = eventCountSlider.value;

        rectCountSlider.addEventListener('input', () => {
            rectCountValue.textContent = rectCountSlider.value;
        });
        doorCountSlider.addEventListener('input', () => {
            doorCountValue.textContent = doorCountSlider.value;
        });
        pathWidthSlider.addEventListener('input', () => {
            pathWidthValue.textContent = pathWidthSlider.value;
        });
        monsterCountSlider.addEventListener('input', () => {
            monsterCountValue.textContent = monsterCountSlider.value;
        });
        eventCountSlider.addEventListener('input', () => {
            eventCountValue.textContent = eventCountSlider.value;
        });

        canvasWidthInput.addEventListener('change', () => {
            let w = parseInt(canvasWidthInput.value);
            if (isNaN(w) || w < 10) w = 10;
            if (w > 100) w = 100;
            config.mapWidth = w;
            canvasWidthInput.value = w;
            generateMap();
        });
        canvasHeightInput.addEventListener('change', () => {
            let h = parseInt(canvasHeightInput.value);
            if (isNaN(h) || h < 10) h = 10;
            if (h > 100) h = 100;
            config.mapHeight = h;
            canvasHeightInput.value = h;
            generateMap();
        });

        imageUploadArea.addEventListener('click', () => {
            tileImageInput.click();
        });
        tileImageInput.addEventListener('change', handleTileImageUpload);

        [doorTopCheckbox, doorRightCheckbox, doorBottomCheckbox, doorLeftCheckbox].forEach(cb => {
            cb.addEventListener('change', generateMap);
        });

        regenerateBtn.addEventListener('click', generateMap);
        generateSpawnBtn.addEventListener('click', generateSpawnPoints);
        generateEventBtn.addEventListener('click', generateEventPoints);
        exportTMXBtn.addEventListener('click', exportToTMX);
        exportTSXBtn.addEventListener('click', exportToTSX);
        editSpawnsBtn.addEventListener('click', () => {
            editMode = !editMode;
            updateEditUI();
        });
        saveSpawnsBtn.addEventListener('click', () => {
            const payload = {
                player: playerSpawnPoint,
                monsters: monsterSpawnPoints,
                events: eventSpawnPoints
            };
            try {
                localStorage.setItem('dungeon_spawns', JSON.stringify(payload));
                editMode = false;
                updateEditUI();
                alert('生成点位置已保存（localStorage）。');
            } catch (e) {
                console.error('保存失败', e);
                alert('保存失败，请查看控制台错误信息。');
            }
        });

        let mapData = [];

        function initMap() {
            config.mapWidth = parseInt(canvasWidthInput.value) || 50;
            config.mapHeight = parseInt(canvasHeightInput.value) || 50;
            canvas.width = config.mapWidth * config.cellSize;
            canvas.height = config.mapHeight * config.cellSize;
            labelsContainer.style.width = canvas.width + 'px';
            labelsContainer.style.height = canvas.height + 'px';

            mapData = Array(config.mapHeight).fill().map(() =>
                Array(config.mapWidth).fill(0)
            );
            monsterSpawnPoints = [];
            playerSpawnPoint = null;
            eventSpawnPoints = [];
            doorPositions = [];
            doorCenters = [];
            labelsContainer.innerHTML = '';
        }

        function generateMainRectPaths(rectCount) {
            const paths = [];
            const edge = config.edgeAvoid;
            const minX = edge;
            const maxX = config.mapWidth - edge - 1;
            const minY = edge;
            const maxY = config.mapHeight - edge - 1;
            const minRectSize = parseInt(minRectSizeInput.value);
            const maxRectSize = parseInt(maxRectSizeInput.value);

            let attemptCount = 0;
            while (paths.length < rectCount && attemptCount < 100) {
                attemptCount++;
                const width = Math.floor(Math.random() * (maxRectSize - minRectSize + 1)) + minRectSize;
                const height = Math.floor(Math.random() * (maxRectSize - minRectSize + 1)) + minRectSize;
                const x = Math.floor(Math.random() * (maxX - width - edge + 1)) + minX;
                const y = Math.floor(Math.random() * (maxY - height - edge + 1)) + minY;

                const isOverlap = paths.some(rect => {
                    return !(x + width < rect.x || x > rect.x + rect.width ||
                             y + height < rect.y || y > rect.y + rect.height);
                });

                if (!isOverlap) {
                    for (let ry = y; ry < y + height; ry++) {
                        for (let rx = x; rx < x + width; rx++) {
                            mapData[ry][rx] = 1;
                        }
                    }
                    paths.push({
                        x, y, width, height,
                        centerX: Math.floor(x + width/2),
                        centerY: Math.floor(y + height/2)
                    });
                }
            }
            return paths;
        }

        function generateDoors() {
            const doors = [];
            const doorSize = config.doorSize;
            const mapWidth = config.mapWidth;
            const mapHeight = config.mapHeight;
            const selectedDirs = [];
            if (doorTopCheckbox.checked) selectedDirs.push('top');
            if (doorRightCheckbox.checked) selectedDirs.push('right');
            if (doorBottomCheckbox.checked) selectedDirs.push('bottom');
            if (doorLeftCheckbox.checked) selectedDirs.push('left');
            doorPositions = [];
            doorCenters = [];

            let useCenter = doorCenterCheckbox.checked;
            let doorCount = parseInt(doorCountSlider.value);

            // 优化：始终遵循通道数量
            let allDirs = ['top', 'right', 'bottom', 'left'];
            let dirsToUse = [];

            if (selectedDirs.length === 0) {
                // 如果没勾选，自动选前doorCount个
                dirsToUse = allDirs.slice(0, doorCount);
            } else if (selectedDirs.length >= doorCount) {
                dirsToUse = selectedDirs.slice(0, doorCount);
            } else {
                // 勾选数不足，补齐
                let remain = doorCount - selectedDirs.length;
                dirsToUse = [...selectedDirs];
                for (let dir of allDirs) {
                    if (!dirsToUse.includes(dir)) {
                        dirsToUse.push(dir);
                        if (dirsToUse.length === doorCount) break;
                    }
                }
            }

            dirsToUse.forEach(dir => {
                let doorX = 0, doorY = 0;
                let mapCenterX = Math.floor(mapWidth / 2);
                let mapCenterY = Math.floor(mapHeight / 2);
                let doorHalfSize = Math.floor(doorSize / 2);

                if (useCenter) {
                    switch (dir) {
                        case 'top':
                            doorY = 0;
                            doorX = mapCenterX - doorHalfSize;
                            break;
                        case 'right':
                            doorX = mapWidth - doorSize;
                            doorY = mapCenterY - doorHalfSize;
                            break;
                        case 'bottom':
                            doorY = mapHeight - doorSize;
                            doorX = mapCenterX - doorHalfSize;
                            break;
                        case 'left':
                            doorX = 0;
                            doorY = mapCenterY - doorHalfSize;
                            break;
                    }
                } else {
                    // 随机分布在边上
                    switch (dir) {
                        case 'top':
                            doorY = 0;
                            doorX = Math.floor(Math.random() * (mapWidth - doorSize));
                            break;
                        case 'right':
                            doorX = mapWidth - doorSize;
                            doorY = Math.floor(Math.random() * (mapHeight - doorSize));
                            break;
                        case 'bottom':
                            doorY = mapHeight - doorSize;
                            doorX = Math.floor(Math.random() * (mapWidth - doorSize));
                            break;
                        case 'left':
                            doorX = 0;
                            doorY = Math.floor(Math.random() * (mapHeight - doorSize));
                            break;
                    }
                }

                doorX = Math.max(0, Math.min(doorX, mapWidth - doorSize));
                doorY = Math.max(0, Math.min(doorY, mapHeight - doorSize));
                for (let dy = 0; dy < doorSize; dy++) {
                    for (let dx = 0; dx < doorSize; dx++) {
                        mapData[doorY + dy][doorX + dx] = 2;
                        doorPositions.push({x: doorX + dx, y: doorY + dy});
                    }
                }
                const centerX = doorX + Math.floor(doorSize/2);
                const centerY = doorY + Math.floor(doorSize/2);
                doorCenters.push({x: centerX, y: centerY});
                doors.push({x: doorX, y: doorY, centerX, centerY});
            });
            return doors;
        }

        function connectTwoPointsWithCustomPath(startX, startY, endX, endY, pathWidth) {
            startX = Math.round(startX);
            startY = Math.round(startY);
            endX = Math.round(endX);
            endY = Math.round(endY);
            const halfWidth = Math.floor(pathWidth / 2);

            if (pathStraightCheckbox && pathStraightCheckbox.checked) {
                // 直线或竖线
                if (startX === endX || startY === endY) {
                    // 已经是直线
                    let x1 = Math.min(startX, endX), x2 = Math.max(startX, endX);
                    let y1 = Math.min(startY, endY), y2 = Math.max(startY, endY);
                    for (let x = x1; x <= x2; x++) {
                        for (let wY = -halfWidth; wY <= halfWidth; wY++) {
                            let cy = startY + wY;
                            if (cy >= config.edgeAvoid && cy < config.mapHeight - config.edgeAvoid &&
                                x >= config.edgeAvoid && x < config.mapWidth - config.edgeAvoid &&
                                mapData[cy][x] !== 2) {
                                mapData[cy][x] = 1;
                            }
                        }
                    }
                    for (let y = y1; y <= y2; y++) {
                        for (let wX = -halfWidth; wX <= halfWidth; wX++) {
                            let cx = startX + wX;
                            if (cx >= config.edgeAvoid && cx < config.mapWidth - config.edgeAvoid &&
                                y >= config.edgeAvoid && y < config.mapHeight - config.edgeAvoid &&
                                mapData[y][cx] !== 2) {
                                mapData[y][cx] = 1;
                            }
                        }
                    }
                } else {
                    // 先横后竖
                    let midX = endX, midY = startY;
                    // 横向
                    let x1 = Math.min(startX, midX), x2 = Math.max(startX, midX);
                    for (let x = x1; x <= x2; x++) {
                        for (let wY = -halfWidth; wY <= halfWidth; wY++) {
                            let cy = startY + wY;
                            if (cy >= config.edgeAvoid && cy < config.mapHeight - config.edgeAvoid &&
                                x >= config.edgeAvoid && x < config.mapWidth - config.edgeAvoid &&
                                mapData[cy][x] !== 2) {
                                mapData[cy][x] = 1;
                            }
                        }
                    }
                    // 竖向
                    let y1 = Math.min(startY, endY), y2 = Math.max(startY, endY);
                    for (let y = y1; y <= y2; y++) {
                        for (let wX = -halfWidth; wX <= halfWidth; wX++) {
                            let cx = endX + wX;
                            if (cx >= config.edgeAvoid && cx < config.mapWidth - config.edgeAvoid &&
                                y >= config.edgeAvoid && y < config.mapHeight - config.edgeAvoid &&
                                mapData[y][cx] !== 2) {
                                mapData[y][cx] = 1;
                            }
                        }
                    }
                }
                return;
            }

            // 原有折线路径
            const dx = Math.abs(endX - startX);
            const dy = Math.abs(endY - startY);
            const sx = startX < endX ? 1 : -1;
            const sy = startY < endY ? 1 : -1;
            let err = dx - dy;

            while (true) {
                for (let wX = -halfWidth; wX <= halfWidth; wX++) {
                    for (let wY = -halfWidth; wY <= halfWidth; wY++) {
                        const currX = startX + wX;
                        const currY = startY + wY;
                        if (currX >= config.edgeAvoid && currX < config.mapWidth - config.edgeAvoid &&
                            currY >= config.edgeAvoid && currY < config.mapHeight - config.edgeAvoid &&
                            mapData[currY][currX] !== 2) {
                            mapData[currY][currX] = 1;
                        }
                    }
                }

                if (startX === endX && startY === endY) break;

                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    startX += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    startY += sy;
                }
            }
        }

        // 新增辅助函数：判断路径是否会与已有路径交叉
        function isPathCrossing(startX, startY, endX, endY, pathWidth) {
            startX = Math.round(startX);
            startY = Math.round(startY);
            endX = Math.round(endX);
            endY = Math.round(endY);
            const halfWidth = Math.floor(pathWidth / 2);

            const dx = Math.abs(endX - startX);
            const dy = Math.abs(endY - startY);
            const sx = startX < endX ? 1 : -1;
            const sy = startY < endY ? 1 : -1;
            let err = dx - dy;

            let x = startX, y = startY;
            while (true) {
                for (let wX = -halfWidth; wX <= halfWidth; wX++) {
                    for (let wY = -halfWidth; wY <= halfWidth; wY++) {
                        const currX = x + wX;
                        const currY = y + wY;
                        if (
                            currX >= config.edgeAvoid && currX < config.mapWidth - config.edgeAvoid &&
                            currY >= config.edgeAvoid && currY < config.mapHeight - config.edgeAvoid
                        ) {
                            // 只允许走在未被占用的区域（0为墙，1为路径，2为门，3为路径墙）
                            // 允许起点和终点重叠
                            if (
                                mapData[currY][currX] === 1 &&
                                !(currX === startX && currY === startY) &&
                                !(currX === endX && currY === endY)
                            ) {
                                return true; // 有交叉
                            }
                        }
                    }
                }
                if (x === endX && y === endY) break;
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }
            return false;
        }

        // 修改connectAllPaths，生成不交叉的路径
        function connectAllPaths(doors, paths) {
            const pathWidth = parseInt(pathWidthSlider.value);
            const usedPairs = [];

            // 连接门到最近的房间中心，避免交叉
            doors.forEach(door => {
                let nearestPath = null;
                let minDist = Infinity;
                let minIndex = -1;
                for (let i = 0; i < paths.length; i++) {
                    const path = paths[i];
                    const dist = Math.hypot(door.centerX - path.centerX, door.centerY - path.centerY);
                    if (
                        dist < minDist &&
                        !usedPairs.some(pair => pair[0] === door.centerX && pair[1] === door.centerY && pair[2] === path.centerX && pair[3] === path.centerY) &&
                        !isPathCrossing(door.centerX, door.centerY, path.centerX, path.centerY, pathWidth)
                    ) {
                        minDist = dist;
                        nearestPath = path;
                        minIndex = i;
                    }
                }
                // 如果找不到不交叉的，允许交叉一次
                if (!nearestPath) {
                    minDist = Infinity;
                    for (let i = 0; i < paths.length; i++) {
                        const path = paths[i];
                        const dist = Math.hypot(door.centerX - path.centerX, door.centerY - path.centerY);
                        if (
                            dist < minDist &&
                            !usedPairs.some(pair => pair[0] === door.centerX && pair[1] === door.centerY && pair[2] === path.centerX && pair[3] === path.centerY)
                        ) {
                            minDist = dist;
                            nearestPath = path;
                            minIndex = i;
                        }
                    }
                }
                if (nearestPath) {
                    connectTwoPointsWithCustomPath(door.centerX, door.centerY, nearestPath.centerX, nearestPath.centerY, pathWidth);
                    usedPairs.push([door.centerX, door.centerY, nearestPath.centerX, nearestPath.centerY]);
                }
            });

            // 连接房间之间，避免交叉
            let connected = new Set();
            connected.add(0);
            while (connected.size < paths.length) {
                let best = null;
                let bestFrom = -1, bestTo = -1, bestDist = Infinity;
                for (let from of connected) {
                    for (let to = 0; to < paths.length; to++) {
                        if (connected.has(to)) continue;
                        const p1 = paths[from], p2 = paths[to];
                        const dist = Math.hypot(p1.centerX - p2.centerX, p1.centerY - p2.centerY);
                        if (
                            dist < bestDist &&
                            !isPathCrossing(p1.centerX, p1.centerY, p2.centerX, p2.centerY, pathWidth)
                        ) {
                            bestDist = dist;
                            bestFrom = from;
                            bestTo = to;
                            best = [p1, p2];
                        }
                    }
                }
                // 如果找不到不交叉的，允许交叉一次
                if (!best) {
                    for (let from of connected) {
                        for (let to = 0; to < paths.length; to++) {
                            if (connected.has(to)) continue;
                            const p1 = paths[from], p2 = paths[to];
                            connectTwoPointsWithCustomPath(p1.centerX, p1.centerY, p2.centerX, p2.centerY, pathWidth);
                            connected.add(to);
                            best = true;
                            break;
                        }
                        if (best) break;
                    }
                } else {
                    connectTwoPointsWithCustomPath(best[0].centerX, best[0].centerY, best[1].centerX, best[1].centerY, pathWidth);
                    connected.add(bestTo);
                }
            }
        }

        function markPathWalls() {
            for (let y = config.edgeAvoid; y < config.mapHeight - config.edgeAvoid; y++) {
                for (let x = config.edgeAvoid; x < config.mapWidth - config.edgeAvoid; x++) {
                    if (mapData[y][x] === 1 || mapData[y][x] === 2) {
                        const dirs = [[-1,0], [1,0], [0,-1], [0,1]];
                        dirs.forEach(([dx, dy]) => {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < config.mapWidth && ny >= 0 && ny < config.mapHeight) {
                                if (mapData[ny][nx] === 0) {
                                    mapData[ny][nx] = 3;
                                }
                            }
                        });
                    }
                }
            }
        }

        function drawMap() {
            ctx.fillStyle = config.colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < config.mapHeight; y++) {
                for (let x = 0; x < config.mapWidth; x++) {
                    const cellX = x * config.cellSize;
                    const cellY = y * config.cellSize;

                    switch (mapData[y][x]) {
                        case 0: ctx.fillStyle = config.colors.normalWall; break;
                        case 1: ctx.fillStyle = config.colors.path; break;
                        case 2: ctx.fillStyle = config.colors.door; break;
                        case 3: ctx.fillStyle = config.colors.pathWall; break;
                    }

                    ctx.fillRect(cellX, cellY,
                        config.cellSize - config.wallThickness,
                        config.cellSize - config.wallThickness);
                }
            }

            drawSpawnPoints(monsterSpawnPoints, config.colors.monsterSpawn);
            if (playerSpawnPoint) {
                drawSpawnPoints([playerSpawnPoint], config.colors.playerSpawn);
            }
            drawSpawnPoints(eventSpawnPoints, config.colors.eventSpawn);
        }

        function drawSpawnPoints(points, color) {
            points.forEach(point => {
                const cellX = point.x * config.cellSize;
                const cellY = point.y * config.cellSize;
                const centerX = cellX + config.cellSize / 2;
                const centerY = cellY + config.cellSize / 2;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, config.cellSize / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        function createAllLabels() {
            labelsContainer.innerHTML = '';
            monsterSpawnPoints.forEach((point, index) => {
                const label = document.createElement('div');
                label.className = 'spawn-label';
                label.textContent = `monster_${index + 1}`;
                label.style.left = (point.x * config.cellSize + 2) + 'px';
                label.style.top = (point.y * config.cellSize - 12) + 'px';
                labelsContainer.appendChild(label);
            });
            if (playerSpawnPoint) {
                const label = document.createElement('div');
                label.className = 'spawn-label';
                label.textContent = 'player';
                label.style.left = (playerSpawnPoint.x * config.cellSize + 2) + 'px';
                label.style.top = (playerSpawnPoint.y * config.cellSize - 12) + 'px';
                labelsContainer.appendChild(label);
            }
            eventSpawnPoints.forEach((point, index) => {
                const label = document.createElement('div');
                label.className = 'event-label';
                label.textContent = `event_${index + 1}`;
                label.style.left = (point.x * config.cellSize + 2) + 'px';
                label.style.top = (point.y * config.cellSize - 12) + 'px';
                labelsContainer.appendChild(label);
            });
        }

        function getDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function getMinDistanceToDoors(x, y) {
            let minDist = Infinity;
            doorPositions.forEach(door => {
                const dist = getDistance({x, y}, door);
                if (dist < minDist) {
                    minDist = dist;
                }
            });
            return minDist;
        }

        function isMonsterSpawnValid(x, y) {
            if (mapData[y][x] !== 1) return false;
            const distToDoor = getMinDistanceToDoors(x, y);
            if (distToDoor < 5) return false;
            for (const point of monsterSpawnPoints) {
                const dist = getDistance({x, y}, point);
                if (dist < 5) return false;
            }
            return true;
        }

        function isPlayerSpawnValid(x, y) {
            if (mapData[y][x] !== 1) return false;
            const distToDoor = getMinDistanceToDoors(x, y);
            let distToMonster = Infinity;
            if (monsterSpawnPoints.length > 0) {
                monsterSpawnPoints.forEach(point => {
                    const dist = getDistance({x, y}, point);
                    if (dist < distToMonster) {
                        distToMonster = dist;
                    }
                });
            }
            return distToDoor === 3 || (monsterSpawnPoints.length > 0 && distToMonster >= 10);
        }

        function isEventSpawnValid(x, y) {
            if (mapData[y][x] !== 1) return false;
            if (playerSpawnPoint && getDistance({x, y}, playerSpawnPoint) < 1) return false;
            for (const monster of monsterSpawnPoints) {
                if (getDistance({x, y}, monster) < 1) return false;
            }
            for (const event of eventSpawnPoints) {
                if (getDistance({x, y}, event) < 10) return false;
            }
            return true;
        }

        function getValidPositionNearDoor(doorCenter) {
            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
            for (const [dx, dy] of directions) {
                const x = doorCenter.x + dx;
                const y = doorCenter.y + dy;
                if (x >= 0 && x < config.mapWidth && y >= 0 && y < config.mapHeight &&
                    mapData[y][x] === 1 && isEventSpawnValid(x, y)) {
                    return {x, y};
                }
            }
            for (let d = 2; d <= 3; d++) {
                const dirs = [[-d,0], [d,0], [0,-d], [0,d]];
                for (const [dx, dy] of dirs) {
                    const x = doorCenter.x + dx;
                    const y = doorCenter.y + dy;
                    if (x >= 0 && x < config.mapWidth && y >= 0 && y < config.mapHeight &&
                        mapData[y][x] === 1 && isEventSpawnValid(x, y)) {
                        return {x, y};
                    }
                }
            }
            return null;
        }

        function generateSpawnPoints() {
            monsterSpawnPoints = [];
            playerSpawnPoint = null;
            const monsterCount = parseInt(monsterCountSlider.value);
            const edge = config.edgeAvoid;
            const maxAttempts = 1000;
            let attempts = 0;
            while (monsterSpawnPoints.length < monsterCount && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * (config.mapWidth - 2 * edge)) + edge;
                const y = Math.floor(Math.random() * (config.mapHeight - 2 * edge)) + edge;
                if (isMonsterSpawnValid(x, y)) {
                    monsterSpawnPoints.push({x, y});
                }
            }
            attempts = 0;
            while (!playerSpawnPoint && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * (config.mapWidth - 2 * edge)) + edge;
                const y = Math.floor(Math.random() * (config.mapHeight - 2 * edge)) + edge;
                if (isPlayerSpawnValid(x, y)) {
                    playerSpawnPoint = {x, y};
                }
            }
            drawMap();
            createAllLabels();
        }

        function generateEventPoints() {
            eventSpawnPoints = [];
            const eventCount = parseInt(eventCountSlider.value);
            const doorCount = doorCenters.length;
            const edge = config.edgeAvoid;
            const maxAttempts = 1000;
            const requiredDoorEvents = Math.min(doorCount, eventCount);
            for (let i = 0; i < requiredDoorEvents; i++) {
                const doorCenter = doorCenters[i];
                const pos = getValidPositionNearDoor(doorCenter);
                if (pos) {
                    eventSpawnPoints.push(pos);
                }
            }
            let attempts = 0;
            while (eventSpawnPoints.length < eventCount && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * (config.mapWidth - 2 * edge)) + edge;
                const y = Math.floor(Math.random() * (config.mapHeight - 2 * edge)) + edge;
                if (isEventSpawnValid(x, y)) {
                    eventSpawnPoints.push({x, y});
                }
            }
            drawMap();
            createAllLabels();
        }

        function generateMap() {
            initMap();
            const rectCount = parseInt(rectCountSlider.value);
            const paths = generateMainRectPaths(rectCount);
            const doors = generateDoors();
            if (paths.length > 0 && doors.length > 0) {
                connectAllPaths(doors, paths);
            }
            markPathWalls();
            drawMap();
            labelsContainer.innerHTML = '';
        }

        function handleTileImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (!file.type.match('image.*')) {
                alert('请上传图片文件（PNG/JPG/JPEG）');
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                uploadedTileImage = file;
                tileImageBase64 = event.target.result;
                tileImagePreview.src = tileImageBase64;
                tileImagePreview.style.display = 'block';
                config.tileSetImageName = file.name;
                alert('图块集图片上传成功！现在可以下载TSX文件了');
            };
            reader.readAsDataURL(file);
        }

        function generateLayerCSV(layerType) {
            let csv = '';
            for (let y = 0; y < config.mapHeight; y++) {
                for (let x = 0; x < config.mapWidth; x++) {
                    let value = 0;
                    switch(layerType) {
                        case 'limit':
                            value = mapData[y][x] === 3 ? 5 : 0;
                            break;
                        case 'channel':
                            value = mapData[y][x] === 2 ? 7 : 0;
                            break;
                        case 'earth':
                            value = mapData[y][x] === 1 ? 2 : 0;
                            break;
                        case 'player':
                            value = (playerSpawnPoint && x === playerSpawnPoint.x && y === playerSpawnPoint.y) ? 1 : 0;
                            break;
                    }
                    csv += value + (x < config.mapWidth - 1 ? ',' : '');
                }
                csv += y < config.mapHeight - 1 ? ',\n' : '';
            }
            return csv;
        }

        function generateObjectGroupXML() {
            let xml = '';
            if (playerSpawnPoint) {
                const x = playerSpawnPoint.x * config.tmxTileSize + config.tmxTileSize / 2;
                const y = playerSpawnPoint.y * config.tmxTileSize + config.tmxTileSize / 2;
                xml += ` <objectgroup color="#aaffff" id="2" name="enterpoint">\n`;
                xml += `  <object id="2" name="enter_1" x="${x.toFixed(2)}" y="${y.toFixed(2)}">\n`;
                xml += `   <properties>\n`;
                xml += `    <property name="id" type="int" value="1"/>\n`;
                xml += `   </properties>\n`;
                xml += `   <point/>\n`;
                xml += `  </object>\n`;
                xml += ` </objectgroup>\n`;
            }
            if (monsterSpawnPoints.length > 0) {
                xml += ` <objectgroup color="#ff00ff" id="5" name="monsterpoint">\n`;
                monsterSpawnPoints.forEach((point, index) => {
                    const id = 13 + index;
                    const x = point.x * config.tmxTileSize + config.tmxTileSize / 2;
                    const y = point.y * config.tmxTileSize + config.tmxTileSize / 2;
                    xml += `  <object id="${id}" name="monster_${index + 1}" x="${x.toFixed(2)}" y="${y.toFixed(2)}">\n`;
                    xml += `   <properties>\n`;
                    xml += `    <property name="id" type="int" value="${index + 1}"/>\n`;
                    xml += `   </properties>\n`;
                    xml += `   <point/>\n`;
                    xml += `  </object>\n`;
                });
                xml += ` </objectgroup>\n`;
            }
            if (eventSpawnPoints.length > 0) {
                xml += ` <objectgroup color="#ffff00" id="6" name="eventpoint">\n`;
                eventSpawnPoints.forEach((point, index) => {
                    const id = 5 + index;
                    const x = point.x * config.tmxTileSize + config.tmxTileSize / 2;
                    const y = point.y * config.tmxTileSize + config.tmxTileSize / 2;
                    xml += `  <object id="${id}" name="event_${index + 1}" x="${x.toFixed(2)}" y="${y.toFixed(2)}">\n`;
                    xml += `   <properties>\n`;
                    xml += `    <property name="id" type="int" value="${index + 1}"/>\n`;
                    xml += `   </properties>\n`;
                    xml += `   <point/>\n`;
                    xml += `  </object>\n`;
                });
                xml += ` </objectgroup>\n`;
            }
            xml += ` <objectgroup id="8" name="dynamiclandscape"/>\n`;
            return xml;
        }

        function generateTSXContent() {
            const tileImageName = uploadedTileImage ? uploadedTileImage.name : config.tileSetImageName;
            const tileSize = config.tmxTileSize;
            const columns = config.tileSetColumns;
            const imageWidth = tileSize * columns;
            const imageHeight = tileSize;
            const tileDefinitions = [
                {id: 0, type: "empty", color: "#FFFFFF"},
                {id: 1, type: "player_spawn", color: "#0000FF"},
                {id: 2, type: "earth", color: "#4CAF50"},
                {id: 3, type: "normal_wall", color: "#666666"},
                {id: 4, type: "path_wall", color: "#000000"},
                {id: 5, type: "limit_area", color: "#000000"},
                {id: 6, type: "monster_spawn", color: "#FF0000"},
                {id: 7, type: "channel", color: "#FF69B4"},
                {id: 8, type: "event_spawn", color: "#FFFF00"},
                {id: 9, type: "reserved", color: "#9C27B0"}
            ];
            let tsxXML = `<?xml version="1.0" encoding="UTF-8"?>
<tileset version="1.10" tiledversion="1.10.2" name="MaskTileSet" tilewidth="${tileSize}" tileheight="${tileSize}" tilecount="${columns}" columns="${columns}">
 <grid orientation="orthogonal" width="1" height="1"/>
 <image source="${tileImageName}" width="${imageWidth}" height="${imageHeight}"/>
`;
            tileDefinitions.forEach(tile => {
                tsxXML += ` <tile id="${tile.id}">\n`;
                tsxXML += `  <properties>\n`;
                tsxXML += `   <property name="type" value="${tile.type}"/>\n`;
                tsxXML += `   <property name="color" value="${tile.color}"/>\n`;
                tsxXML += `  </properties>\n`;
                tsxXML += ` </tile>\n`;
            });
            tsxXML += `</tileset>`;
            return tsxXML;
        }

        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportToTMX() {
            if (monsterSpawnPoints.length === 0 && !playerSpawnPoint && eventSpawnPoints.length === 0) {
                alert('请先生成怪物/玩家出生点和特殊事件点后再导出TMX文件！');
                return;
            }
            let outName = outputNameInput.value.trim();
            if (!outName) outName = 'dungeon_map';
            const tmxXML = `<?xml version="1.0" encoding="UTF-8"?>
<map version="1.10" tiledversion="1.10.2" orientation="orthogonal" renderorder="right-down" width="${config.mapWidth}" height="${config.mapHeight}" tilewidth="${config.tmxTileSize}" tileheight="${config.tmxTileSize}" infinite="0" nextlayerid="9" nextobjectid="23">
 <tileset firstgid="1" source="MaskTileSet.tsx"/>
 <tileset firstgid="9" source="../theme1_cemetery/MaskTileSet.tsx"/>
 <layer id="4" name="策划限制区域(没用)" width="${config.mapWidth}" height="${config.mapHeight}">
  <data encoding="csv">
${generateLayerCSV('limit')}
</data>
 </layer>
 <layer id="3" name="channel" width="${config.mapWidth}" height="${config.mapHeight}">
  <data encoding="csv">
${generateLayerCSV('channel')}
</data>
 </layer>
 <layer id="1" name="earth" width="${config.mapWidth}" height="${config.mapHeight}">
  <data encoding="csv">
${generateLayerCSV('earth')}
</data>
 </layer>
${generateObjectGroupXML()}
 <layer id="7" name="player" width="${config.mapWidth}" height="${config.mapHeight}">
  <data encoding="csv">
${generateLayerCSV('player')}
</data>
 </layer>
</map>`;
            downloadFile(tmxXML, `${outName}.tmx`, 'application/xml');
        }

        function exportToTSX() {
            if (!uploadedTileImage) {
                alert('请先上传你的图块集图片！');
                return;
            }
            const tsxContent = generateTSXContent();
            downloadFile(tsxContent, 'MaskTileSet.tsx', 'application/xml');
            const imageBlob = dataURLtoBlob(tileImageBase64);
            const imageUrl = URL.createObjectURL(imageBlob);
            const a = document.createElement('a');
            a.href = imageUrl;
            a.download = uploadedTileImage.name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(imageUrl);
        }

        function dataURLtoBlob(dataURL) {
            const arr = dataURL.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while(n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], {type:mime});
        }

        generateMap();

        function updateEditUI() {
            if (editMode) {
                editSpawnsBtn.textContent = '停止编辑';
                saveSpawnsBtn.style.display = 'inline-block';
                canvas.style.cursor = 'crosshair';
            } else {
                editSpawnsBtn.textContent = '编辑生成点';
                saveSpawnsBtn.style.display = 'none';
                canvas.style.cursor = 'default';
            }
        }

        function getMouseGridPos(e) {
            const rect = canvas.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;
            const gx = Math.floor(offsetX / config.cellSize);
            const gy = Math.floor(offsetY / config.cellSize);
            return { x: gx, y: gy, offsetX, offsetY };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!editMode) return;
            const { x: gx, y: gy, offsetX, offsetY } = getMouseGridPos(e);
            if (playerSpawnPoint) {
                const px = playerSpawnPoint.x * config.cellSize + config.cellSize / 2;
                const py = playerSpawnPoint.y * config.cellSize + config.cellSize / 2;
                const dist = Math.hypot(offsetX - px, offsetY - py);
                if (dist <= spawnPickRadiusPx) {
                    dragging = { type: 'player', index: null };
                    return;
                }
            }
            for (let i = 0; i < monsterSpawnPoints.length; i++) {
                const p = monsterSpawnPoints[i];
                const px = p.x * config.cellSize + config.cellSize / 2;
                const py = p.y * config.cellSize + config.cellSize / 2;
                const dist = Math.hypot(offsetX - px, offsetY - py);
                if (dist <= spawnPickRadiusPx) {
                    dragging = { type: 'monster', index: i };
                    return;
                }
            }
            for (let i = 0; i < eventSpawnPoints.length; i++) {
                const p = eventSpawnPoints[i];
                const px = p.x * config.cellSize + config.cellSize / 2;
                const py = p.y * config.cellSize + config.cellSize / 2;
                const dist = Math.hypot(offsetX - px, offsetY - py);
                if (dist <= spawnPickRadiusPx) {
                    dragging = { type: 'event', index: i };
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { x: gx, y: gy } = getMouseGridPos(e);
            const cx = Math.max(0, Math.min(config.mapWidth - 1, gx));
            const cy = Math.max(0, Math.min(config.mapHeight - 1, gy));
            if (mapData[cy][cx] !== 1) {
                let found = false;
                const checks = [[0,0],[-1,0],[1,0],[0,-1],[0,1]];
                for (const [dx, dy] of checks) {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx >=0 && nx < config.mapWidth && ny >=0 && ny < config.mapHeight && mapData[ny][nx] === 1) {
                        if (dragging.type === 'player') playerSpawnPoint = { x: nx, y: ny };
                        else if (dragging.type === 'monster') monsterSpawnPoints[dragging.index] = { x: nx, y: ny };
                        else eventSpawnPoints[dragging.index] = { x: nx, y: ny };
                        found = true;
                        break;
                    }
                }
                if (!found) return;
            } else {
                if (dragging.type === 'player') playerSpawnPoint = { x: cx, y: cy };
                else if (dragging.type === 'monster') monsterSpawnPoints[dragging.index] = { x: cx, y: cy };
                else if (dragging.type === 'event') eventSpawnPoints[dragging.index] = { x: cx, y: cy };
            }
            drawMap();
            createAllLabels();
        });

        window.addEventListener('mouseup', (e) => {
            if (dragging) dragging = null;
        });

        (function tryLoadSavedSpawns(){
            try {
                const raw = localStorage.getItem('dungeon_spawns');
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (parsed.player) playerSpawnPoint = parsed.player;
                if (Array.isArray(parsed.monsters)) monsterSpawnPoints = parsed.monsters;
                if (Array.isArray(parsed.events)) eventSpawnPoints = parsed.events;
                createAllLabels();
                drawMap();
            } catch (e) {
                console.error('恢复保存生成点失败', e);
            }
        })();
    </script>
</body>
</html>
